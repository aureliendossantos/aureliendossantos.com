---
import { WorkType } from "generated/prisma/client"
import BaseLayout from "$layouts/BaseLayout.astro"
import "@fontsource/google-sans-code"
// Supports weights 200-900
import "@fontsource-variable/crimson-pro"

const scoreEmojis = ["üö´", "üò§", "ü´§", "üôÇ", "‚ù§Ô∏è", "‚≠êÔ∏è"]

let inputClass =
	"w-full bg-fi-bg-2 px-[10px] text-[13px] leading-9 text-fi-tx transition placeholder:text-fi-base-500 focus:outline-none dark:bg-fi-dark-bg-2 dark:text-fi-dark-tx dark:placeholder:text-fi-base-500 dark:focus:bg-fi-dark-bg ring-0 ring-fi-ui-2 focus:ring-2 focus:bg-fi-bg dark:ring-fi-dark-ui-2"
---

<BaseLayout title="Write a review" ogType="website" bg={{ light: "#FFFCF0", dark: "#100F0F" }}>
	<div class="mx-auto max-w-2xl text-sm text-fi-tx dark:text-fi-dark-tx">
		<form id="createReviewForm" class="space-y-6 px-6">
			<div
				class="sticky top-0 z-30 flex items-center justify-between bg-fi-bg pb-1 pt-3 shadow-md shadow-fi-bg dark:bg-fi-dark-bg dark:shadow-fi-dark-bg"
			>
				<a
					href="/catalogue"
					class="bg-fi-ui px-[10px] font-medium leading-9 text-fi-tx-2 dark:bg-fi-dark-ui dark:text-fi-dark-tx-2"
				>
					{"<"} Catalogue
				</a>
				<button
					type="submit"
					class="bg-fi-ui px-[10px] font-medium leading-9 text-fi-tx-2 dark:bg-fi-dark-ui dark:text-fi-dark-tx-2"
				>
					Post Review
				</button>
			</div>
			<!-- Search Section -->
			<div>
				<div class="relative">
					<input
						type="text"
						id="searchInput"
						placeholder="Search for a work..."
						autocomplete="off"
						class={`${inputClass} z-20`}
					/>
					<div
						id="searchResults"
						class="absolute left-0 right-0 top-[calc(100%+2px)] z-10 hidden max-h-[300px] overflow-y-auto bg-fi-bg ring-2 ring-fi-ui-2 dark:bg-fi-dark-bg dark:ring-fi-dark-ui-2"
					>
					</div>
				</div>
				<button
					type="button"
					id="toggleManualForm"
					class="mt-1 text-[13px] text-fi-tx-3 underline hover:text-fi-tx dark:text-fi-dark-tx-3 dark:hover:text-fi-dark-tx"
				>
					Find Work Manually
				</button>
			</div>

			<!-- Manual Form (Hidden by Default) -->
			<div
				id="manualForm"
				class="hidden space-y-4 border-l-2 border-fi-ui-2 pl-4 dark:border-fi-dark-ui-2"
			>
				<div>
					<label for="source" class="mb-1 block text-sm">Source:</label>
					<select id="source" name="source" class={`${inputClass} h-9 font-google-sans-code !px-2`}>
						<option value="">Select a source</option>
						{Object.values(WorkType).map((type) => <option value={type}>{type}</option>)}
					</select>
				</div>

				<div>
					<label for="sourceId" class="mb-1 block text-sm">Slug (IGDB) or ID:</label>
					<input
						type="text"
						id="sourceId"
						name="sourceId"
						class={`${inputClass} font-google-sans-code`}
					/>
				</div>

				<button
					type="button"
					id="fetchButton"
					class="bg-fi-ui px-[14px] py-2 hover:bg-fi-ui-2 dark:bg-fi-dark-ui dark:hover:bg-fi-dark-ui-2"
				>
					Preview
				</button>
			</div>

			<!-- Work Preview -->
			<div id="workPreview" class="hidden space-y-4 bg-fi-bg-2 dark:bg-fi-dark-bg-2">
				<div id="previewContent"></div>
				<button
					type="button"
					id="saveButton"
					class="hidden bg-fi-blue px-4 py-2 text-white hover:opacity-90 dark:bg-fi-dark-blue"
				>
					Save to DB
				</button>
			</div>

			<!-- Review Fields -->
			<div>
				<input
					type="date"
					id="createdAt"
					name="createdAt"
					class={`${inputClass} font-google-sans-code`}
				/>
			</div>
			<div>
				<label
					class="mb-2 block font-medium uppercase tracking-wider text-fi-tx-2"
					style="font-family: 'Crimson Pro Variable', serif;"
				>
					Score
				</label>
				<div class="flex gap-1">
					{
						scoreEmojis.map((emoji, index) => (
							<label class="cursor-pointer rounded-full px-2 py-1 transition hover:bg-fi-bg-2 has-[:checked]:bg-fi-blue-50 dark:hover:bg-fi-dark-ui dark:has-[:checked]:bg-fi-blue-900">
								<input type="radio" name="score" value={index} class="hidden" />
								{emoji}
							</label>
						))
					}
				</div>
			</div>
			<div>
				<div>
					<label
						class="mb-2 block font-medium uppercase tracking-wider text-fi-tx-2"
						style="font-family: 'Crimson Pro Variable', serif;"
					>
						Emotions
					</label>
					<div id="emotionsContainer" class="-mx-[6px] flex flex-wrap gap-2">
						<!-- Emotions will be loaded via JavaScript -->
					</div>
				</div>
			</div>
			<textarea
				id="content"
				name="content"
				class="mt-4 min-h-[6lh] w-full bg-fi-bg text-lg text-fi-tx outline-none placeholder:text-fi-tx-3 dark:bg-fi-dark-bg dark:text-fi-dark-tx dark:placeholder:text-fi-dark-tx-3"
				style="font-family: 'Crimson Pro Variable', serif;field-sizing: content;"
				placeholder="Thoughts..."></textarea>
		</form>

		<style is:global>
			::-webkit-resizer {
				display: none;
			}
		</style>

		<script>
			import { actions } from "astro:actions"
			import { toast } from "$utils/navbar"
			import getIGDBimageUrl, { type IGDBData } from "$utils/remoteData/igdbClient"
			import getTMDBimageUrl, { type TMDBData } from "$utils/remoteData/tmdbClient"
			import type { SpotifyAlbum, SpotifyTrack } from "$utils/remoteData/spotifyClient"
			import formatDate from "$utils/formatting/formatDate"

			const toggleManualForm = document.getElementById("toggleManualForm") as HTMLButtonElement
			const manualForm = document.getElementById("manualForm") as HTMLDivElement
			const fetchButton = document.getElementById("fetchButton") as HTMLButtonElement
			const workPreview = document.getElementById("workPreview") as HTMLDivElement
			const previewContent = document.getElementById("previewContent") as HTMLDivElement
			const saveButton = document.getElementById("saveButton") as HTMLButtonElement
			const createReviewForm = document.getElementById("createReviewForm") as HTMLFormElement
			const emotionsContainer = document.getElementById("emotionsContainer") as HTMLDivElement
			const searchInput = document.getElementById("searchInput") as HTMLInputElement
			const searchResults = document.getElementById("searchResults") as HTMLDivElement

			let currentWorkData:
				| { type: "IGDB"; data: IGDBData }
				| { type: "TMDB"; data: TMDBData }
				| { type: "SpotifyAlbum"; data: SpotifyAlbum }
				| { type: "SpotifyTrack"; data: SpotifyTrack }
				| null = null
			let currentWorkId: string | null = null
			let searchTimeout: number | null = null

			async function loadEmotions() {
				const { data, error } = await actions.getEmotions()
				if (error) {
					console.error("Error loading emotions:", error)
					return
				}

				const emotions = data.emotions
				emotionsContainer.innerHTML = emotions
					.map(
						(emotion) => `
						<label class="cursor-pointer rounded-full px-[6px] ring-0 transition hover:bg-fi-bg-2 has-[:checked]:bg-fi-blue-50 has-[:checked]:text-fi-blue dark:hover:bg-fi-dark-ui dark:has-[:checked]:bg-fi-blue-950 dark:has-[:checked]:text-fi-dark-blue">
							<input type="checkbox" name="emotions" value="${emotion.id}" class="hidden" />
							${emotion.emoji} ${emotion.englishTitle}
						</label>
					`
					)
					.join("")
			}
			loadEmotions()

			// Toggle manual form visibility
			toggleManualForm.addEventListener("click", () => {
				manualForm.classList.toggle("hidden")
				toggleManualForm.textContent = manualForm.classList.contains("hidden")
					? "Find Work Manually"
					: "Hide Manual Form"
			})

			async function previewFromIGDB(slug: string) {
				const { data, error } = await actions.getIGDBdata({ slug })
				if (error) {
					toast(`Error: ${error}`, 12000)
					return
				}
				currentWorkData = { type: "IGDB", data: data.igdb }
				displayWorkPreview(
					data.igdb.name,
					data.igdb.developers || "Unknown",
					data.igdb.cover ? getIGDBimageUrl(data.igdb.cover.image_id, "cover_big") : null,
					null,
					true,
					false
				)
			}

			async function previewFromTMDB(id: number) {
				const { data, error } = await actions.getTMDBdata({ id })
				if (error) {
					toast(`Error: ${error}`, 12000)
					return
				}
				const directors = data.tmdb.credits.crew
					.filter((c) => c.job === "Director")
					.map((c) => c.name)
					.join(", ")
				currentWorkData = { type: "TMDB", data: data.tmdb }
				displayWorkPreview(
					data.tmdb.title,
					directors || "Unknown",
					data.tmdb.poster_path ? getTMDBimageUrl(185, data.tmdb.poster_path) : null,
					null,
					true,
					false
				)
			}

			async function previewFromSpotifyAlbum(id: string) {
				const { data: album, error } = await actions.getSpotifyAlbum({ id })
				if (error) {
					toast(`Error: ${error}`, 12000)
					return
				}
				currentWorkData = { type: "SpotifyAlbum", data: album }
				displayWorkPreview(
					album.name,
					album.artists.map((a) => a.name).join(", "),
					album.images[0]?.url || null,
					null,
					true,
					false
				)
			}

			async function previewFromSpotifyTrack(id: string) {
				const { data: track, error } = await actions.getSpotifyTrack({ id })
				if (error) {
					toast(`Error: ${error}`, 12000)
					return
				}
				currentWorkData = { type: "SpotifyTrack", data: track }
				displayWorkPreview(
					track.name,
					track.artists.map((a) => a.name).join(", "),
					track.album.images[0]?.url || null,
					null,
					true,
					false
				)
			}

			// Search functionality
			searchInput.addEventListener("input", () => {
				if (searchTimeout) clearTimeout(searchTimeout)
				const query = searchInput.value.trim()

				if (query.length < 2) {
					searchResults.classList.add("hidden")
					return
				}

				searchTimeout = window.setTimeout(async () => {
					// Fetch both database and API results
					const [dbResponse, apiResponse] = await Promise.all([
						actions.searchWorks({ query }),
						actions.searchInAPIs({ query }),
					])

					if (dbResponse.error) {
						console.error("DB Search error:", dbResponse.error)
					}
					if (apiResponse.error) {
						console.error("API Search error:", apiResponse.error)
					}

					const dbWorks = dbResponse.data?.works || []
					const apiGames = apiResponse.data?.igdb || []
					const apiMovies = apiResponse.data?.tmdb || []
					const apiAlbums = apiResponse.data?.spotify?.albums || []
					const apiTracks = apiResponse.data?.spotify?.tracks || []

					if ([...dbWorks, ...apiGames, ...apiMovies, ...apiAlbums, ...apiTracks].length === 0) {
						searchResults.innerHTML =
							'<div class="p-2 text-fi-tx-3 dark:text-fi-dark-tx-3">No results found</div>'
						searchResults.classList.remove("hidden")
						return
					}

					let html = ""

					// DB results
					if (dbWorks.length > 0) {
						html += searchResultTitleDiv("In My Collection")
						html += dbWorks
							.map((work) =>
								searchResultDiv(
									"search-result-db",
									work.id,
									work.title,
									work.authors.join(", "),
									work.sourceCover
								)
							)
							.join("")
					}

					// IGDB results
					if (apiGames.length > 0) {
						html += searchResultTitleDiv("Games")
						html += apiGames
							.map((work) =>
								searchResultDiv(
									"search-result-api-igdb",
									work.slug,
									`${work.name} ${work.first_release_date ? `(${new Date(work.first_release_date * 1000).getFullYear()})` : ""}`,
									`${work.developers || ""} ${work.platforms ? `¬∑ ${work.platforms.map((p) => p.abbreviation).join(", ")}` : ""}`,
									work.cover && getIGDBimageUrl(work.cover.image_id, "cover_small")
								)
							)
							.join("")
					}

					// TMDB results
					if (apiMovies.length > 0) {
						html += searchResultTitleDiv("Movies")
						html += apiMovies
							.map((movie) => {
								return searchResultDiv(
									"search-result-api-tmdb",
									movie.id,
									`${movie.title} (${formatDate(new Date(movie.release_date), true)})`,
									movie.title !== movie.original_title ? movie.original_title : undefined,
									movie.poster_path && getTMDBimageUrl(92, movie.poster_path)
								)
							})
							.join("")
					}

					// Spotify Albums
					if (apiAlbums.length > 0) {
						html += searchResultTitleDiv("Albums")
						html += apiAlbums
							.map((album) => {
								const year = album.release_date ? new Date(album.release_date).getFullYear() : ""
								return searchResultDiv(
									"search-result-api-spotify-album",
									album.id,
									`${album.name} ${year ? `(${year})` : ""}`,
									album.artists.map((a) => a.name).join(", "),
									album.images[album.images.length - 1]?.url
								)
							})
							.join("")
					}

					// Spotify Tracks
					if (apiTracks.length > 0) {
						html += searchResultTitleDiv("Tracks")
						html += apiTracks
							.map((track) => {
								return searchResultDiv(
									"search-result-api-spotify-track",
									track.id,
									track.name,
									`${track.artists.map((a) => a.name).join(", ")} ¬∑ ${track.album.name}`,
									track.album.images[track.album.images.length - 1]?.url
								)
							})
							.join("")
					}

					searchResults.innerHTML = html
					searchResults.classList.remove("hidden")

					// Add click handlers for DB results
					document.querySelectorAll(".search-result-db").forEach((item) => {
						item.addEventListener("click", async () => {
							const workId = (item as HTMLElement).dataset.workId!
							searchInput.value = (item as HTMLElement).querySelector(".title")!.textContent || ""
							searchResults.classList.add("hidden")

							const work = dbWorks.find((w) => w.id === workId)
							if (work) {
								displayWorkPreview(
									work.title,
									work.authors.join(", "),
									work.sourceCover,
									workId,
									false,
									true
								)
							}
							updateWorkInReview(workId)
						})
					})

					// Add click handlers for API results - IGDB
					document.querySelectorAll(".search-result-api-igdb").forEach((item) => {
						item.addEventListener("click", async () => {
							const slug = (item as HTMLElement).dataset.workId!
							searchInput.value = (item as HTMLElement).querySelector(".title")!.textContent || ""
							searchResults.classList.add("hidden")

							await previewFromIGDB(slug)
						})
					})

					// Add click handlers for API results - TMDB
					document.querySelectorAll(".search-result-api-tmdb").forEach((item) => {
						item.addEventListener("click", async () => {
							const id = parseInt((item as HTMLElement).dataset.workId!)
							searchInput.value = (item as HTMLElement).querySelector(".title")!.textContent || ""
							searchResults.classList.add("hidden")

							await previewFromTMDB(id)
						})
					})

					// Add click handlers for API results - Spotify Albums
					document.querySelectorAll(".search-result-api-spotify-album").forEach((item) => {
						item.addEventListener("click", async () => {
							const id = (item as HTMLElement).dataset.workId!
							searchInput.value = (item as HTMLElement).querySelector(".title")!.textContent || ""
							searchResults.classList.add("hidden")

							await previewFromSpotifyAlbum(id)
						})
					})

					// Add click handlers for API results - Spotify Tracks
					document.querySelectorAll(".search-result-api-spotify-track").forEach((item) => {
						item.addEventListener("click", async () => {
							const id = (item as HTMLElement).dataset.workId!
							searchInput.value = (item as HTMLElement).querySelector(".title")!.textContent || ""
							searchResults.classList.add("hidden")

							await previewFromSpotifyTrack(id)
						})
					})
				}, 300)
				// 300ms debounce
			})

			// Show search results when input gains focus
			searchInput.addEventListener("focus", () => {
				const query = searchInput.value.trim()
				if (query.length >= 2 && searchResults.children.length > 0) {
					searchResults.classList.remove("hidden")
				}
			})

			// Close search results when clicking outside
			document.addEventListener("click", (e) => {
				if (!searchInput.contains(e.target as Node) && !searchResults.contains(e.target as Node)) {
					searchResults.classList.add("hidden")
				}
			})

			// Fetch button from the "Find Work Manually" form
			fetchButton.addEventListener("click", async () => {
				const source = (document.getElementById("source") as HTMLSelectElement).value
				const sourceId = (document.getElementById("sourceId") as HTMLInputElement).value
				if (!source || !sourceId) return

				if (source === "VideoGame") {
					await previewFromIGDB(sourceId)
				} else if (source === "Movie") {
					await previewFromTMDB(parseInt(sourceId))
				} else if (source === "MusicAlbum") {
					await previewFromSpotifyAlbum(sourceId)
				} else if (source === "MusicTrack") {
					await previewFromSpotifyTrack(sourceId)
				} else {
					toast("Error: Unsupported source")
					return
				}
			})

			saveButton.addEventListener("click", async () => {
				if (!currentWorkData) return
				saveButton.disabled = true

				let result
				if (currentWorkData.type === "IGDB") {
					result = await actions.createWorkFromIGDB({ slug: currentWorkData.data.slug })
				} else if (currentWorkData.type === "TMDB") {
					result = await actions.createWorkFromTMDB({ id: currentWorkData.data.id })
				} else if (currentWorkData.type === "SpotifyAlbum") {
					result = await actions.createWorkFromSpotifyAlbum({
						id: currentWorkData.data.id,
					})
				} else if (currentWorkData.type === "SpotifyTrack") {
					result = await actions.createWorkFromSpotifyTrack({
						id: currentWorkData.data.id,
					})
				} else {
					toast("Error: Unknown work data type")
					saveButton.disabled = false
					return
				}

				const { data, error } = result
				if (error) {
					toast(`Error: ${error}`, 12000)
					saveButton.disabled = false
					return
				}

				// Refresh preview with local work data
				displayWorkPreview(
					data.work.title,
					data.work.authors.join(", "),
					data.work.sourceCover,
					data.work.id,
					false,
					true
				)
				updateWorkInReview(data.work.id)
				currentWorkData = null
				saveButton.disabled = false
			})

			createReviewForm.addEventListener("submit", async (e) => {
				e.preventDefault()

				if (!currentWorkId) {
					toast("Please select a work first.")
					return
				}

				const formData = new FormData(createReviewForm)
				const score = formData.get("score")
				const content = formData.get("content") as string
				const createdAtString = formData.get("createdAt") as string

				// Get selected emotions
				const emotionCheckboxes = emotionsContainer.querySelectorAll(
					'input[type="checkbox"]:checked'
				) as NodeListOf<HTMLInputElement>
				const emotionIds = Array.from(emotionCheckboxes).map((cb) => parseInt(cb.value))

				if (score === null) {
					toast("Please select a score.")
					return
				}

				// Combine selected date with current time
				let createdAt: Date | undefined
				if (createdAtString) {
					const selectedDate = new Date(createdAtString)
					const now = new Date()
					createdAt = new Date(
						selectedDate.getFullYear(),
						selectedDate.getMonth(),
						selectedDate.getDate(),
						now.getHours(),
						now.getMinutes(),
						now.getSeconds()
					)
				}

				const { data, error } = await actions.createReview({
					workId: currentWorkId,
					emotionIds,
					content: content || undefined,
					score: parseInt(score as string),
					createdAt,
				})

				if (error) {
					toast(`Error: ${error}`, 12000)
					return
				}

				toast("Review posted successfully.")
				createReviewForm.reset()
				searchInput.value = ""
				workPreview.classList.add("hidden")
				saveButton.classList.add("hidden")
				currentWorkData = null
				updateWorkInReview(null)
			})

			function updateWorkInReview(workId: string | null) {
				currentWorkId = workId
			}

			function displayWorkPreview(
				title: string,
				authors: string,
				coverUrl: string | null,
				workId: string | null,
				showSaveButton: boolean,
				isLocal: boolean
			) {
				workPreview.classList.remove("hidden")

				const sourceTag = isLocal
					? '<span class="bg-fi-tx-2 px-1 py-0.5 text-xs font-medium uppercase text-fi-bg dark:bg-fi-dark-tx-2 dark:text-fi-dark-bg">Local</span>'
					: '<span class="bg-fi-tx-2 px-1 py-0.5 text-xs font-medium uppercase text-fi-bg dark:bg-fi-dark-tx-2 dark:text-fi-dark-bg">Remote</span>'

				previewContent.innerHTML = `
				<div class="flex gap-4">
					${coverUrl ? `<img src="${coverUrl}" alt="Cover" class="w-[88px] h-auto object-cover" />` : ""}
					<div class="flex-1 flex flex-col py-4">
						<h3 class="text-base text-fi-tx-2 font-medium">${title}</h3>
						<p class="text-sm text-fi-tx-2 dark:text-fi-dark-tx-2">${authors}</p>
						<div class="grow h-2"></div>
						<div class="flex">${sourceTag}</div>
					</div>
				</div>
			`

				if (showSaveButton) {
					saveButton.classList.remove("hidden")
				} else {
					saveButton.classList.add("hidden")
				}
			}

			function searchResultTitleDiv(title: string) {
				return `<div class="sticky top-0 px-[6px] leading-6 text-xs font-semibold text-fi-tx-2 dark:text-fi-dark-tx-2 bg-fi-ui dark:bg-fi-dark-ui">${title}</div>`
			}

			function searchResultDiv(
				specifierClass: string,
				workId: number | string,
				title: string,
				details?: string,
				coverUrl?: string | null
			) {
				return `
	  <div 
		class="${specifierClass} flex items-center cursor-pointer hover:bg-fi-bg-2 dark:hover:bg-fi-dark-bg-2 transition-colors group"
		style="box-shadow: inset 0 -1px 0 rgba(0, 0, 0, 0.10)"
		data-work-id="${workId}"
	  >
	  ${coverUrl ? `<img class="w-12 object-cover self-stretch" src="${coverUrl}" alt="Cover" />` : `<div class="w-12"></div>`}
	  <div class="grow px-3 py-2 dark:border-fi-dark-ui">
		<div class="title font-semibold leading-snug">${title}</div>
		${details ? `<div class="details text-xs leading-[22px] text-fi-tx-2 dark:text-fi-dark-tx-2">${details}</div>` : ""}
		</div>
	  </div>
	`
			}
		</script>
	</div>
</BaseLayout>
